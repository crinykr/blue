#####################################
## 속도X, 코드단순화O, 구조단순화O ##
#####################################



# To run Bash Shell Program
- RTOS 기반
- 파일시스템 : 램디스크


# TO DO LIST
- "tcb_t *parent = get_cur_task(get_core_num());" 이런식으로 현재태스크 얻기 보다는, cpu별로 페이징 설정을 한페이지 정도 다르게 해서 "tcb_t *parent = kernel_currnet_task;" 이런식으로 메모리엑세스를 통해 바로 얻을 수 있게.
- get_pid() 구현

fork...ok
scheduling...ok
..................more hardning!!!!!!!!!!!!!!!!!!!!!
...........

* 멀티코어 관련 작업
- scheduler
- 동기화객체
- get_cpuid() : 프로세스 당 페이징 구현 통해서

* 파일시스템
* 가상메모리
* 스레드 지원
* api 지원관련
* 로더 : 라이브러리 관련




# 기타 150416
- "tcb_t *parent = get_cur_task(get_core_num());" 이런식으로 현재태스크 얻기 보다는, cpu별로 페이징 설정을 한페이지 정도 다르게 해서 "tcb_t *parent = kernel_currnet_task;" 이런식으로 메모리엑세스를 통해 바로 얻을 수 있게.
- 기존 리눅스의 Idle 프로세스, 페이징 커널 스레드(migration thread), acpid 관련 스레드등, 스레드들은 커널 스레드가 아닌, 타이머 인터럽트시에 적당한 주기를 보고 호출하는 형식으로...
(커널스레드 등록으로 인해 스케줄링 되어 부여받는 런타임 시간이나, 위와 같이 타이머 인터럽트시에 잠시 런타임되는 것이 별 다른 차이가 없을 것으로 사료됨)


# 프로세스관리
- 커널스레드는 없앰. 
- 리눅스 프로세스구조체 계승
- 스케쥴러는 없애고 인터럽트 기반으로 간단하게

# 매모리관리
- 리눅스 계승

# 인터럽트관리
- 프로세스당 커널 스택을 없애고, 코어당 인터러스 스택으로 일원화.
- 자동 스케쥴이 되게 새로 설계
- 리얼타임을 아예 고려하지 않거나?, 리얼타임이 자연스래 되도록?











//////////////////////////////////////////////////////////////////////////
1. 코드정리

2. 리눅스 프로세스구조체, 메모리디자인 계승, 인터럽트 구조 계승
- posix 호환 고려
- 디바이스급 호환은 고려x

3. 간단한 시분할 스케쥴링으로 변경

3-2. 리눅스 시스템 호환 테스스

4. 인터럽트 구조 재설계하면서 자동 응답 스케쥴기능 접목
- 리얼타임을 포기하면서 초빠른 응답의 인터럽트기반 프로세스동작
- 초저전력


